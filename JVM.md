                                                                   JVM 


## 一：JVM基础知识

1：什么是JVM？
JVM是一种规范,人们常说Java是跨平台的语言,而JVM帮助屏蔽了不同操作系统的底层，是跨语言的平台．
它不仅仅应用于Java语言，它是可以认识所有能编译成.class格式的文件（二进制字节码文件）．

2：好处
* 一次编写，到处运行的基石：java通过JVM 跨平台，JVM 屏蔽了字节码与底层操作系统之间的差异，对外提供了一个一致的运行环境。JVM解释执行字节码
* 自动内存的管理机制，垃圾回收功能：虽然现在很多语言都有这个功能，但java出现较早，竞争对手是C，C++，无需手动释放内存
* 数组下标越界的检查：抛出异常，C语言没有数组下标越界检查，一旦数组越界，可能覆盖其他代码的内存。
* 多态：面向对象编程的基石：java使用虚方法表的方式来实现多态

3：JVM和JDK,JRE的关系(面试)

![binaryTree](tmp/jvm-image/JVM和JDK,JRE的关系.png.jpg "binaryTree")

4：常见的JVM

![binaryTree](tmp/jvm-image/常见的JVM.png "binaryTree")

其中，我们目前安装JDk使用的是HotSpot,这个是oracle官方那个是用的,有很多实力公司不依赖oracle公司的这个,他们会根据JVM规范自己实现一些虚拟机,
比如淘宝的是TaobaoVM(免费,Java虚拟机收费大家可以可以使用这个),还有商业版本收费，垃圾回收最快的azul zing(有钱公司使用).
所以说:一流的公司制造规范,二流的公司实现规范,三流的公司使用规范.

5: JVM的学习步骤
  1: 类加载器
  2：JVM内存模型
  3：执行引擎：解释器，即时编译器（JIT编译热点代码），GC垃圾回收  
  4：操作系统：本地方法接口


## 二：JVM 内存模型
 1：程序计数器：Program Counter Register

![binaryTree](tmp/jvm-image/程序计数器.png "binaryTree")
  * 作用：通过寄存器来实现，记录下一条JVM指令的执行地址。方便线程上下文切换,记录线程执行到那条指令
  * 特点：线程私有的。JVM中，唯一一个不会出现内存溢出的区。

2：虚拟机栈：线程运行需要的内存空间，线程私有
 栈：先进后出
 一个栈由多个栈帧组成。一个战帧对应一次方法的调用，栈帧是方法运行时需要的内存。
注意：每个线程只能有一个活动栈帧，对应着正在执行的那个方法。
 栈帧(主要四个部分组成)：
*  Local Variable Table:本地变量(局部变量)表,方法内部使用的,参数也算在内，以变量槽为最小单位，每个槽32位的内存空间。
   局部变量表主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类原始数据类型、对象引用(reference)，
   以及returnAddress类型。局部变量表所需的容量大小在编译期就可以被完全确定下来，并保存在方法的Code属性中。
*  Operand Stack:操作数栈(表达式栈)
   对于long的处理（store and load），多数虚拟机的实现都是原子的
   局部变量，没必要加volatile，线程私有的。
   操作数栈所需的容量大小在编译期就可以被完全确定下来，并保存在方法的Code属性中。通过标准的出入栈完成数据访问
   32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。
* Dynamic Linking:动态链接,指向常量池的符号链接,如果没有解析,就去动态解析
   https://blog.csdn.net/qq_41813060/article/details/88379473
   jvms 2.6.3
* return address:返回值地址
   a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方
  
问题：
--垃圾回收是否涉及栈内存？ 不需要，方法执行完会弹栈
--栈内存分配越大越好吗？  可以通过参数-Xss控制，windows系统受虚拟内存影响，其他系统默认1MB。栈越大，会导致线程数变少;大了可以更多次方法的调用
--方法内的局部变量是否线程安全？ 如果方法内局部变量没有逃离方法的作用范围，那么就是线程安全；如果变量引用了对象，并逃离范围，需要考虑安全问题。

栈内存溢出：
 * 栈帧过多，比如多次的递归调用，这个比较常见
 * 栈帧过大，这个很少发生。

  


 


